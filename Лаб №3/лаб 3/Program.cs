namespace лаб_3
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int n = 10; // количество членов суммы
            double k = 10;
            double x, step, sn = 0, se = 0, a = 0.1, b = 1, e = 0.0001;
            double an; // текущий член суммы
            double y; // сама функция
            double recurrenceRelation; // рекуррентное соотношение
            x = a;
            step = (b - a) / k; // из за неточностей типа double вместо 0,09 step равняется 0,08999999999999999667,
                                // что помешает нам записать в условии для выхода из цикла просто while(x < b),
                                // потому что иначе вместо ожидаемых 10 раз цикл выполнется 11 раз
            while (Math.Abs(x - b) >= 0.01) // так как типы с плавающей запятой не всегда способны
                                            // точно представлять свои точные десятичные значения,
                                            // (в нашем случае проблемы возникают из за step типа double, на который меняется x)
                                            // то мы выходим из цикла, когда x сильно приблизится к b 
            {
                double a1 = x;
                an = a1; // изначально первый член суммы
                         //double recurrenceRelation = (-1)*((x * x) / (4 * n * n + 2 * n)); // подсчёт рекуррентного соотношения для текущего x
                sn = 0;
                for (int i = 1; i <= n; i++) // цикл выполнится 10 раз: в результате
                                             // к sn прибавятся члены суммы от a1 до a10
                                             // i - номер текущего члена суммы
                {
                    recurrenceRelation = (-1) * ((x * x) / (4 * i * i + 2 * i)); // подсчёт рекуррентного соотношения для текущего x
                    sn += an;
                    an = an * recurrenceRelation;
                }
                an = a1;
                se = a1; // присваиваем se значение a1, так как в цикле мы сразу будем изменять an
                double u = 1; // u - номер  текущего члена суммы
                do
                {
                    recurrenceRelation = (-1) * ((x * x) / (4 * u * u + 2 * u)); // подсчёт рекуррентного соотношения для текущего x
                    an = an * recurrenceRelation;
                    se += an;
                    u++;
                } while (Math.Abs(an) >= e); // выходим из цикла, когда an достигло заданной точности e
                y = Math.Sin(x); // подсчёт функции через формулу без использования рекуррентного соотношения
                Console.WriteLine($"X={x:f2} SN={sn:f10} SE={se:f10} Y={y:f10}"); // выводим результат для каждого x
                x += step; // изменяем x на посчитанный нами шаг

            }
        }
    }
}